import argparse
import boto
from datetime import datetime,timedelta
from etool import queue,logs
import json
import math

__processor__ = 'bayesian_model'
log = logs.getLogger(__processor__)
log.init()

"""
Applying bayesian model to predict the stock flucturation
"""
KEYID = ""
SECRETKEY = ""
CONFIG = {}

def parse_args():
    ap = argparse.ArgumentParser("Apply the bayesian model to predict stock warning")
    ap.add_argument('-c',dest="model_cfg",metavar="MODEL CFG",default="./bayesian_model.cfg",type=str,nargs='?',help='the config file')
    ap.add_argument('-tf',dest="trend_file",metavar="TREND RANGE FILE",default="./trendRange.json", type=str,nargs='?',help="The trend range file")
    ap.add_argument('-z',dest="port",metavar="ZMQ PORT",default="tcp://*:30115",type=str,nargs="?",help="The zmq port")
    ap.add_argument('-k',dest="key_id",metavar="KeyId for AWS",type=str,nargs="+",help="The key id for aws")
    ap.add_argument('-s',dest="secret",metavar="secret key for AWS",type=str,nargs="+",help="The secret key for aws")
    return ap.parse_args() 

def get_domain(domain_name):
    conn = boto.connect_sdb(KEYID,SECRETKEY)
    conn.create_domain(domain_name)
    return conn.get_domain(domain_name)

def check_if_tradingday(self,predict_date,stock_index):
        "Check if the day weekend"
        week_day = datetime.strptime(predict_date,"%Y-%m-%d").weekday()
        if week_day == 5 or week_day == 6:
            log.info("%s For %s is Weekend, Just Skip!" %(predict_date,stock_index))
            return False
        
        "Check if the day is holiday"
        domain = get_domain("s_holiday")
        sql = "select count(*) from s_holiday where stock_index='{}' and date = {}".format(stock_index,predict_date)
        result = domain.select(sql)
        count = result["Count"]
        if count == 0:
            return True
        else:
            log.info( "%s For %s is Holiday, Just Skip!" %(stock_index,stock_index))
            return False

# calculate the stock index contribution for the coming day
def compute_stock_index_probability(predict_date, cluster_type , stock_index, duration=3 ):
    try:
        "Get the clusters List"
        cluster_probability = CONFIG["clusterProbability"]
        cluster_json = {}
        cluster_contribution_json = {}
        cluster_json = cluster_probability[stock_index]
        "Get the contribution of each cluster"
        cluster_contribution_json = CONFIG["clusterContribution"]
        
        #get the past n days trend type 
        cluster_types_history = []
        stock_derived = []
        domain_name = "bloomberg_enrichedindex"
        domain = get_domain(domain_name)
        sql = "select trendType,embersId from {} where date < '{}' and stock_index = '{}' order by date desc limit {}".format(domain_name,predict_date,stock_index,duration)
        results = domain.select(sql)
        for result in results:
            cluster_types_history.append(result["trendType"])
            stock_derived.append(result["embersId"])
         
        #computing probability   
        stock_probability = 0
        for key in cluster_contribution_json[stock_index].keys():
            if key == str(cluster_type):
                "Search from the Cluster contribution Matrix to get the contribution probability"
                stock_probability = stock_probability + math.log( float( cluster_contribution_json[stock_index][key][int( cluster_types_history[0] ) - 1][2] ) ) + math.log( float( cluster_contribution_json[stock_index][key][int( cluster_types_history[1] ) - 1][1] ) ) + math.log( float( cluster_contribution_json[stock_index][key][int( cluster_types_history[2] ) - 1][0] ) ) + math.log( float( cluster_json[str( cluster_type )] ) )
        
        return stock_probability,stock_derived
    except Exception as e:
        log.info( "Error in computing stock index probability: %s" % e.args)

# calculate the stock news contribution for the coming day
def compute_stock_news_probability(predict_date, cluster_type , stock_index,duraiton=3 ):
    try:
        term_contribution_json = CONFIG["termContribution"]
        #get the past n day's news
        "Get past 3 day's news before Predictive Day "
        predict_date = datetime.strptime(predict_date, "%Y-%m-%d" )
        start_day = ( predict_date - timedelta( days = 3 ) ).strftime( "%Y-%m-%d" )
        end_day = ( predict_date - timedelta( days = 1 ) ).strftime( "%Y-%m-%d" )
        sqlquery = "select content,embers_id from t_daily_enrichednews where post_date>=? and post_date<=? and stock_index=?"
        
        cur.execute( sqlquery, ([startDay, endDay , stockIndex]))
        articleRecords = cur.fetchall()
        
        "Initiate the words List"
        vocabularyFile = open(common.get_configuration( "training", 'VOCABULARY_FILE'))
        wordLines = vocabularyFile.readlines()
        termList = {}
        for line in wordLines:
            line = line.replace("\n","").replace("\r","")
            termList[line] = 0
            
        newsDerived = []
        "Merge all the term in each record"
        for record in articleRecords:
            jsonRecord = json.loads(record[0])
            newsDerived.append(record[1])
            for curWord in jsonRecord:
                if curWord in termList:
                    termList[curWord] = termList[curWord] + jsonRecord[curWord]
        
        return termList,newsDerived
        
        
        
        termContributionProbability = 0
        if stock_index in term_contribution_json:
            for term_cluster_type in term_contribution_json[stock_index].keys():
                if term_cluster_type == str(cluster_type):    
                    stermlist = term_contribution_json[stock_index][term_cluster_type]
                    #print stermlist                            
                    for word, count in terms.iteritems():                    
                        if word in stermlist:                        
                            #print word
                            termContributionProbability =  count * math.log( float( term_contribution_json[stock_index][term_cluster_type][word] ) )
                            del stermlist[word]
        
        return termContributionProbability,newsDerived
    except IOError:
        log.info( "Can't open the file:stock_raw_data.json.")
    except Exception as e:
        log.info( "Error in computing stock news probability: %s" % e.message)    
    return None
    